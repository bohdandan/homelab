#!/usr/bin/env bash

set -e

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load color and print functions
source "$SCRIPT_DIR/lib/colors.sh"

CONFIG_FILE="$SCRIPT_DIR/../.env"

# Load existing config if it exists
load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        source "$CONFIG_FILE"
        return 0
    fi
    return 1
}

# Save config to file
save_config() {
    cat > "$CONFIG_FILE" << EOF
# Proxmox Configuration
# Generated by setup-proxmox.sh
PROXMOX_HOST="$PROXMOX_HOST"
PROXMOX_USER="$PROXMOX_USER"
PROXMOX_PORT="$PROXMOX_PORT"
EOF

    # Add API token if it exists
    if [[ -n "$PROXMOX_API_TOKEN" ]]; then
        cat >> "$CONFIG_FILE" << EOF
PROXMOX_API_TOKEN="$PROXMOX_API_TOKEN"
EOF
    fi

    chmod 600 "$CONFIG_FILE"
    print_info "Configuration saved to: $CONFIG_FILE"
}

# Create Proxmox user if it doesn't exist
create_proxmox_user() {
    local user_part="$1"
    local realm_part="$2"

    print_step "Checking if user exists..."

    # Check if user exists
    local user_exists
    user_exists=$(ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" \
        "pveum user list --output-format json" 2>&1 | grep -c "\"userid\":\"$user_part@$realm_part\"" || true)

    if [[ "$user_exists" -eq 0 ]]; then
        print_info "User $user_part@$realm_part does not exist. Creating..."

        # Create the user
        ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" \
            "pveum user add $user_part@$realm_part --comment 'OpenTofu automation user'"

        if [[ $? -ne 0 ]]; then
            print_error "Failed to create user"
            return 1
        fi

        print_info "✓ User created"

        # Create custom role for OpenTofu with all necessary permissions
        print_info "Creating custom OpenTofu role with required permissions..."
        ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" bash << 'EOF'
# Delete role if it exists to recreate with correct permissions
pveum role delete OpenTofu 2>/dev/null || true

# Create role with all required permissions for Terraform/OpenTofu
pveum role add OpenTofu -privs "VM.Allocate VM.Clone VM.Config.CDROM VM.Config.CPU VM.Config.Disk VM.Config.HWType VM.Config.Memory VM.Config.Network VM.Config.Options VM.Monitor VM.PowerMgmt Datastore.AllocateSpace Datastore.Audit Pool.Allocate SDN.Use Sys.Audit Sys.Modify"

echo "✓ OpenTofu role created"
EOF

        if [[ $? -ne 0 ]]; then
            print_error "Failed to create OpenTofu role"
            return 1
        fi

        print_info "✓ OpenTofu role created"

        # Grant the custom role to the user
        print_info "Granting OpenTofu role to user..."
        ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" \
            "pveum aclmod / -user $user_part@$realm_part -role OpenTofu"

        if [[ $? -ne 0 ]]; then
            print_error "Failed to grant OpenTofu role"
            return 1
        fi

        print_info "✓ OpenTofu role granted"
    else
        print_info "User $user_part@$realm_part already exists"
        
        # Ensure custom role exists and permissions are set
        print_info "Verifying OpenTofu role and permissions..."
        ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" bash << 'EOF'
# Delete role if it exists to recreate with correct permissions
pveum role delete OpenTofu 2>/dev/null || true

# Create role with all required permissions
pveum role add OpenTofu -privs "VM.Allocate VM.Clone VM.Config.CDROM VM.Config.CPU VM.Config.Disk VM.Config.HWType VM.Config.Memory VM.Config.Network VM.Config.Options VM.Monitor VM.PowerMgmt Datastore.AllocateSpace Datastore.Audit Pool.Allocate SDN.Use Sys.Audit Sys.Modify"

echo "✓ OpenTofu role updated"
EOF

        # Grant the role to the existing user
        ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" \
            "pveum aclmod / -user $user_part@$realm_part -role OpenTofu"
        
        print_info "✓ Permissions verified and updated"
    fi

    return 0
}

# Create API token for OpenTofu
create_api_token() {
    local token_user="$1"
    local token_id="$2"

    print_step "Creating API token on Proxmox..."
    echo ""

    # Extract user and realm from token_user (e.g., terraform@pve -> terraform and pve)
    local user_part=$(echo "$token_user" | cut -d'@' -f1)
    local realm_part=$(echo "$token_user" | cut -d'@' -f2)

    # Create user if it doesn't exist
    if ! create_proxmox_user "$user_part" "$realm_part"; then
        print_error "Failed to create or verify user"
        return 1
    fi

    echo ""

    # Create the token via SSH
    # --privsep 0 means no privilege separation (token has same permissions as user)
    local token_output
    token_output=$(ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" \
        "pveum user token add $user_part@$realm_part $token_id --privsep 0 --output-format json" 2>&1)

    if [[ $? -ne 0 ]]; then
        # Check if token already exists
        if echo "$token_output" | grep -q "already exists"; then
            print_warn "Token already exists. Do you want to remove and recreate it?"
            read -p "Remove existing token? (y/n): " remove_token
            if [[ "$remove_token" == "y" || "$remove_token" == "Y" ]]; then
                print_info "Removing existing token..."
                ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" \
                    "pveum user token remove $user_part@$realm_part $token_id"

                # Try creating again
                token_output=$(ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" \
                    "pveum user token add $user_part@$realm_part $token_id --privsep 0 --output-format json" 2>&1)

                if [[ $? -ne 0 ]]; then
                    print_error "Failed to create token: $token_output"
                    return 1
                fi
            else
                print_warn "Skipping token creation"
                return 1
            fi
        else
            print_error "Failed to create token: $token_output"
            return 1
        fi
    fi

    # Extract the token value from JSON output
    local token_value
    token_value=$(echo "$token_output" | grep -o '"value":"[^"]*"' | cut -d'"' -f4)

    if [[ -z "$token_value" ]]; then
        print_error "Failed to extract token value from output"
        return 1
    fi

    # Format: USER@REALM!TOKENID=SECRET
    PROXMOX_API_TOKEN="${token_user}!${token_id}=${token_value}"

    print_info "✓ API token created successfully!"
    echo ""
    echo "Token ID: $token_id"
    echo "Full token: $PROXMOX_API_TOKEN"
    echo ""
    print_warn "IMPORTANT: This token will be saved to .env"
    print_warn "           Keep this file secure and never commit it to git"
    echo ""

    return 0
}

# Setup SSH key authentication
setup_ssh_key() {
    print_step "Setting up SSH key authentication..."
    echo ""

    # Default SSH key path
    local ssh_key_path="$HOME/.ssh/id_rsa.pub"

    # Check if default key exists
    if [[ -f "$ssh_key_path" ]]; then
        print_info "Found SSH public key at: $ssh_key_path"
        cat "$ssh_key_path"
        echo ""
        read -p "Use this key? (y/n): " use_default_key

        if [[ "$use_default_key" != "y" && "$use_default_key" != "Y" ]]; then
            read -p "Enter path to your SSH public key: " custom_ssh_key
            ssh_key_path="$custom_ssh_key"
        fi
    else
        print_warn "No SSH public key found at: $ssh_key_path"
        read -p "Do you want to generate a new SSH key? (y/n): " generate_key

        if [[ "$generate_key" == "y" || "$generate_key" == "Y" ]]; then
            local private_key="${ssh_key_path%.pub}"
            print_info "Generating new SSH key pair..."
            ssh-keygen -t rsa -b 4096 -f "$private_key" -N "" -C "homelab-$(whoami)@$(hostname)"
            print_info "✓ SSH key generated at: $ssh_key_path"
        else
            read -p "Enter path to your SSH public key: " custom_ssh_key
            ssh_key_path="$custom_ssh_key"
        fi
    fi

    # Verify the key file exists
    if [[ ! -f "$ssh_key_path" ]]; then
        print_error "SSH public key not found at: $ssh_key_path"
        return 1
    fi

    # Read the public key
    local ssh_public_key
    ssh_public_key=$(cat "$ssh_key_path")

    echo ""
    print_info "Checking if SSH key is already on Proxmox server..."

    # Check if key already exists on Proxmox
    local key_exists
    key_exists=$(ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" \
        "grep -q '$(echo "$ssh_public_key" | awk '{print $2}')' ~/.ssh/authorized_keys 2>/dev/null && echo 'yes' || echo 'no'")

    if [[ "$key_exists" == "yes" ]]; then
        print_info "✓ SSH key already exists on Proxmox server"
        echo ""
        print_info "Testing SSH connection..."
        if ssh -o BatchMode=yes -o ConnectTimeout=5 -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" "exit" 2>/dev/null; then
            print_info "✓ SSH key authentication working!"
        else
            print_warn "SSH key exists but authentication failed"
            print_info "You may need to check permissions on ~/.ssh/authorized_keys"
        fi
        return 0
    fi

    echo ""
    print_info "SSH key not found on server. Adding it now..."
    print_info "You will be prompted for your Proxmox password"
    echo ""

    # Copy SSH key to Proxmox
    if command -v ssh-copy-id >/dev/null 2>&1; then
        # Use ssh-copy-id if available
        if ssh-copy-id -i "$ssh_key_path" -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST"; then
            print_info "✓ SSH key copied successfully!"
        else
            print_error "Failed to copy SSH key"
            return 1
        fi
    else
        # Manual method
        if ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" \
            "mkdir -p ~/.ssh && chmod 700 ~/.ssh && echo '$ssh_public_key' >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys"; then
            print_info "✓ SSH key copied successfully!"
        else
            print_error "Failed to copy SSH key"
            return 1
        fi
    fi

    echo ""
    print_info "Testing SSH key authentication..."
    if ssh -o BatchMode=yes -o ConnectTimeout=5 -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" "exit" 2>/dev/null; then
        print_info "✓ SSH key authentication working!"
        echo ""
        print_info "You can now connect to Proxmox without a password:"
        echo "  ssh -p $PROXMOX_PORT $PROXMOX_USER@$PROXMOX_HOST"
    else
        print_error "SSH key authentication test failed"
        return 1
    fi

    return 0
}

# Create OpenTofu terraform.tfvars file
create_terraform_tfvars() {
    local tfvars_dir="$SCRIPT_DIR/../opentofu"
    local tfvars_file="$tfvars_dir/terraform.tfvars"
    local tfvars_example="$tfvars_dir/terraform.tfvars.example"

    # Check if opentofu directory exists
    if [[ ! -d "$tfvars_dir" ]]; then
        print_warn "OpenTofu directory not found: $tfvars_dir"
        return 1
    fi

    # Check if example file exists
    if [[ ! -f "$tfvars_example" ]]; then
        print_warn "Example file not found: $tfvars_example"
        return 1
    fi

    print_step "Creating OpenTofu configuration..."
    echo ""

    # Construct API URL
    local api_url="https://${PROXMOX_HOST}:8006/api2/json"

    # Create terraform.tfvars from example
    if [[ -f "$tfvars_file" ]]; then
        print_warn "terraform.tfvars already exists"
        read -p "Overwrite it with new configuration? (y/n): " overwrite
        if [[ "$overwrite" != "y" && "$overwrite" != "Y" ]]; then
            print_info "Keeping existing terraform.tfvars"
            return 0
        fi
    fi

    # Parse token components
    # PROXMOX_API_TOKEN format: USER@REALM!TOKENID=SECRET
    local full_token_id="${PROXMOX_API_TOKEN%=*}"
    local token_secret="${PROXMOX_API_TOKEN#*=}"

    # Create terraform.tfvars by replacing values in the example
    # Using a more reliable approach than sed for cross-platform compatibility
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS sed requires -i '' for in-place editing
        cp "$tfvars_example" "$tfvars_file"
        sed -i '' "s|proxmox_api_url.*=.*|proxmox_api_url = \"$api_url\"|" "$tfvars_file"
        sed -i '' "s|proxmox_api_token_id.*=.*|proxmox_api_token_id = \"$full_token_id\"|" "$tfvars_file"
        # Uncomment and set secret
        sed -i '' "s|# proxmox_api_token_secret.*=.*|proxmox_api_token_secret = \"$token_secret\"|" "$tfvars_file"
    else
        # Linux sed
        cp "$tfvars_example" "$tfvars_file"
        sed -i "s|proxmox_api_url.*=.*|proxmox_api_url = \"$api_url\"|" "$tfvars_file"
        sed -i "s|proxmox_api_token_id.*=.*|proxmox_api_token_id = \"$full_token_id\"|" "$tfvars_file"
        # Uncomment and set secret
        sed -i "s|# proxmox_api_token_secret.*=.*|proxmox_api_token_secret = \"$token_secret\"|" "$tfvars_file"
    fi

    chmod 600 "$tfvars_file"

    print_info "✓ Created: $tfvars_file"
    echo ""
    print_info "OpenTofu is now configured and ready to use!"
    echo ""

    return 0
}

# Fix Proxmox repository configuration (disable enterprise, enable no-subscription)
fix_proxmox_repositories() {
    print_step "Fixing Proxmox repository configuration..."
    echo ""

    print_info "This will disable enterprise repositories and enable community repositories"
    read -p "Proceed with repository fix? (y/n): " fix_repos

    if [[ "$fix_repos" != "y" && "$fix_repos" != "Y" ]]; then
        print_info "Skipping repository fix"
        return 1
    fi

    echo ""
    print_info "Disabling enterprise repositories..."

    # Disable or comment out enterprise repositories
    ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" bash << 'EOF'
# Find and disable all enterprise repository files
find /etc/apt/sources.list.d/ -type f -name "*.list" | while read file; do
    if grep -q "enterprise.proxmox.com" "$file" 2>/dev/null; then
        # Comment out lines containing enterprise.proxmox.com
        sed -i 's/^deb\(.*enterprise\.proxmox\.com.*\)/#deb\1/g' "$file"
        echo "✓ Disabled enterprise repos in: $(basename $file)"
    fi
done

# Also check main sources.list
if grep -q "enterprise.proxmox.com" /etc/apt/sources.list 2>/dev/null; then
    sed -i 's/^deb\(.*enterprise\.proxmox\.com.*\)/#deb\1/g' /etc/apt/sources.list
    echo "✓ Disabled enterprise repos in: sources.list"
fi

# Specifically handle common enterprise repo files
for repo_file in pve-enterprise.list ceph.list; do
    if [ -f "/etc/apt/sources.list.d/$repo_file" ]; then
        sed -i 's/^deb/#deb/g' "/etc/apt/sources.list.d/$repo_file"
        echo "✓ Disabled: $repo_file"
    fi
done

echo "✓ All enterprise repositories disabled"
EOF

    if [[ $? -ne 0 ]]; then
        print_error "Failed to disable enterprise repositories"
        return 1
    fi

    echo ""
    print_info "Enabling community (no-subscription) repositories..."

    # Add no-subscription repository if not present
    ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" bash << 'EOF'
# Add PVE no-subscription repo if not already present
if ! grep -q "pve-no-subscription" /etc/apt/sources.list.d/*.list 2>/dev/null && \
   ! grep -q "pve-no-subscription" /etc/apt/sources.list 2>/dev/null; then

    # Determine the Debian version
    if grep -q "trixie" /etc/os-release; then
        DEBIAN_VERSION="trixie"
    elif grep -q "bookworm" /etc/os-release; then
        DEBIAN_VERSION="bookworm"
    else
        DEBIAN_VERSION="bookworm"  # default fallback
    fi

    echo "deb http://download.proxmox.com/debian/pve $DEBIAN_VERSION pve-no-subscription" > /etc/apt/sources.list.d/pve-no-subscription.list
    echo "✓ Added pve-no-subscription repository for $DEBIAN_VERSION"
else
    echo "✓ No-subscription repository already configured"
fi
EOF

    if [[ $? -ne 0 ]]; then
        print_error "Failed to enable no-subscription repository"
        return 1
    fi

    echo ""
    print_info "Updating package lists..."

    # Update apt cache - capture output to check if it's just warnings
    local update_output
    update_output=$(ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" "apt-get update 2>&1")
    local update_exit_code=$?

    # Display the output
    echo "$update_output"

    # Check if update succeeded or had only warnings
    if [[ $update_exit_code -eq 0 ]]; then
        print_info "✓ Package lists updated successfully"
    else
        # Check if we still have errors about enterprise repos
        if echo "$update_output" | grep -q "enterprise.proxmox.com"; then
            print_warn "Enterprise repository errors still present"
            print_info "Attempting to remove enterprise repository files completely..."

            # Remove the enterprise repo files entirely
            ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" bash << 'EOF'
# Remove enterprise repository files entirely
for repo_file in pve-enterprise.list ceph.list; do
    if [ -f "/etc/apt/sources.list.d/$repo_file" ]; then
        rm -f "/etc/apt/sources.list.d/$repo_file"
        echo "✓ Removed: $repo_file"
    fi
done

# Find and remove any .sources files with enterprise repos
find /etc/apt/sources.list.d/ -type f \( -name "*.list" -o -name "*.sources" \) | while read file; do
    if grep -q "enterprise.proxmox.com" "$file" 2>/dev/null; then
        rm -f "$file"
        echo "✓ Removed: $(basename $file)"
    fi
done
EOF

            # Try update one more time
            print_info "Retrying package list update..."
            ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" "apt-get update"

            if [[ $? -ne 0 ]]; then
                print_error "Failed to update package lists"
                return 1
            fi
        else
            print_error "Failed to update package lists"
            return 1
        fi
    fi

    print_info "✓ Repository configuration fixed successfully!"
    echo ""

    return 0
}

# Create Ubuntu Noble template on Proxmox
create_ubuntu_template() {
    print_step "Creating Ubuntu Noble Template on Proxmox"
    echo ""

    # Configuration variables with defaults
    local storage="${1:-local-lvm}"
    local vm_id="${2:-9000}"
    local vm_name="${3:-ubuntu-noble-template}"
    local memory="${4:-2048}"
    local cores="${5:-2}"
    local ubuntu_version="noble"
    local image_url="https://cloud-images.ubuntu.com/${ubuntu_version}/current/${ubuntu_version}-server-cloudimg-amd64.img"
    local image_file="/tmp/${ubuntu_version}-server-cloudimg-amd64.img"

    print_info "Template configuration:"
    echo "  VM ID: $vm_id"
    echo "  VM Name: $vm_name"
    echo "  Storage: $storage"
    echo "  Memory: ${memory}MB"
    echo "  CPU Cores: $cores"
    echo "  Ubuntu Version: $ubuntu_version"
    echo ""

    read -p "Proceed with template creation? (y/n): " proceed
    if [[ "$proceed" != "y" && "$proceed" != "Y" ]]; then
        print_info "Template creation cancelled"
        return 0
    fi

    echo ""
    print_info "Checking prerequisites..."

    # Check if libguestfs-tools is installed
    local needs_install=false
    if ! ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" "command -v virt-customize >/dev/null 2>&1"; then
        print_warn "libguestfs-tools not found on Proxmox server"
        needs_install=true
    fi

    if [[ "$needs_install" == "true" ]]; then
        print_info "Installing libguestfs-tools on Proxmox server..."
        ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" \
            "apt-get update && apt-get install -y libguestfs-tools" 2>&1 | tee /tmp/apt-install.log

        if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
            # Check if the error is related to enterprise repositories
            if grep -q "enterprise.proxmox.com" /tmp/apt-install.log || \
               grep -q "401 Unauthorized" /tmp/apt-install.log || \
               grep -q "is not signed" /tmp/apt-install.log; then

                print_error "Failed to install libguestfs-tools due to repository issues"
                echo ""
                print_warn "This appears to be a Proxmox repository configuration issue."
                print_info "Your server is trying to access enterprise repositories without a subscription."
                echo ""

                # Offer to fix repositories
                if fix_proxmox_repositories; then
                    # Retry installation after fixing repos
                    print_info "Retrying libguestfs-tools installation..."
                    ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" \
                        "apt-get install -y libguestfs-tools"

                    if [[ $? -ne 0 ]]; then
                        print_error "Failed to install libguestfs-tools after repository fix"
                        rm -f /tmp/apt-install.log
                        return 1
                    fi
                    print_info "✓ libguestfs-tools installed"
                else
                    print_error "Cannot proceed without fixing repositories"
                    rm -f /tmp/apt-install.log
                    return 1
                fi
            else
                print_error "Failed to install libguestfs-tools"
                rm -f /tmp/apt-install.log
                return 1
            fi
        else
            print_info "✓ libguestfs-tools installed"
        fi
        rm -f /tmp/apt-install.log
    else
        print_info "✓ Prerequisites satisfied"
    fi

    echo ""
    print_info "Checking if VM ID $vm_id already exists..."

    # Check if VM already exists
    if ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" "qm status $vm_id >/dev/null 2>&1"; then
        print_warn "VM with ID $vm_id already exists"
        read -p "Destroy existing VM and recreate template? (y/n): " destroy_vm

        if [[ "$destroy_vm" == "y" || "$destroy_vm" == "Y" ]]; then
            print_info "Destroying VM $vm_id..."
            ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" "qm destroy $vm_id"

            if [[ $? -ne 0 ]]; then
                print_error "Failed to destroy VM"
                return 1
            fi
            print_info "✓ VM destroyed"
        else
            print_info "Template creation cancelled"
            return 0
        fi
    fi

    echo ""
    print_info "Downloading Ubuntu $ubuntu_version cloud image..."

    # Download the image on Proxmox server
    ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" \
        "wget -O $image_file $image_url 2>&1 | grep -E '(saved|error)' || true"

    if [[ $? -ne 0 ]]; then
        print_error "Failed to download Ubuntu image"
        return 1
    fi
    print_info "✓ Image downloaded"

    echo ""
    print_info "Installing qemu-guest-agent in the image..."

    # Install qemu-guest-agent using virt-customize
    ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" \
        "virt-customize -a $image_file --install qemu-guest-agent"

    if [[ $? -ne 0 ]]; then
        print_error "Failed to install qemu-guest-agent"
        # Clean up downloaded image
        ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" "rm -f $image_file"
        return 1
    fi
    print_info "✓ qemu-guest-agent installed"

    echo ""
    print_info "Creating VM $vm_id..."

    # Create the VM
    ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" \
        "qm create $vm_id --name $vm_name --memory $memory --cores $cores --net0 virtio,bridge=vmbr0"

    if [[ $? -ne 0 ]]; then
        print_error "Failed to create VM"
        ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" "rm -f $image_file"
        return 1
    fi
    print_info "✓ VM created"

    echo ""
    print_info "Importing disk to storage..."

    # Import the disk
    ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" \
        "qm importdisk $vm_id $image_file $storage"

    if [[ $? -ne 0 ]]; then
        print_error "Failed to import disk"
        ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" "qm destroy $vm_id && rm -f $image_file"
        return 1
    fi
    print_info "✓ Disk imported"

    echo ""
    print_info "Configuring VM hardware..."

    # Configure the VM
    ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" bash << EOF
qm set $vm_id --scsihw virtio-scsi-pci --scsi0 $storage:vm-$vm_id-disk-0
qm set $vm_id --ide2 $storage:cloudinit
qm set $vm_id --boot c --bootdisk scsi0
qm set $vm_id --serial0 socket --vga serial0
qm set $vm_id --agent enabled=1
EOF

    if [[ $? -ne 0 ]]; then
        print_error "Failed to configure VM"
        ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" "qm destroy $vm_id && rm -f $image_file"
        return 1
    fi
    print_info "✓ VM configured"

    echo ""
    print_info "Converting VM to template..."

    # Convert to template
    ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" "qm template $vm_id"

    if [[ $? -ne 0 ]]; then
        print_error "Failed to convert VM to template"
        return 1
    fi
    print_info "✓ Template created"

    echo ""
    print_info "Cleaning up..."

    # Clean up the downloaded image
    ssh -p "$PROXMOX_PORT" "$PROXMOX_USER@$PROXMOX_HOST" "rm -f $image_file"

    if [[ $? -eq 0 ]]; then
        print_info "✓ Cleanup complete"
    fi

    echo ""
    print_info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    print_info "✓ Ubuntu Noble template created successfully!"
    print_info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    echo "Template Details:"
    echo "  VM ID: $vm_id"
    echo "  Name: $vm_name"
    echo "  Storage: $storage"
    echo "  Ubuntu Version: Noble (24.04)"
    echo ""
    print_info "You can now clone this template to create new VMs:"
    echo "  qm clone $vm_id <new-vm-id> --name <new-vm-name>"
    echo ""

    return 0
}

echo "================================================"
echo "  Proxmox Configuration Setup"
echo "================================================"
echo ""

# Check for existing configuration
if load_config; then
    print_info "Found existing Proxmox configuration:"
    echo "  Host: $PROXMOX_HOST"
    echo "  User: $PROXMOX_USER"
    echo "  Port: $PROXMOX_PORT"
    if [[ -n "$PROXMOX_API_TOKEN" ]]; then
        # Mask the token value for security
        token_masked="${PROXMOX_API_TOKEN%=*}=***"
        echo "  API Token: $token_masked"
    fi
    echo ""
    read -p "Use this configuration? (y/n): " use_existing_config

    if [[ "$use_existing_config" != "y" && "$use_existing_config" != "Y" ]]; then
        print_step "Enter new Proxmox connection details"
        echo ""
        read -p "Proxmox hostname or IP: " PROXMOX_HOST
        read -p "Proxmox username (default: root): " PROXMOX_USER
        PROXMOX_USER=${PROXMOX_USER:-root}
        read -p "Proxmox SSH port (default: 22): " PROXMOX_PORT
        PROXMOX_PORT=${PROXMOX_PORT:-22}

        # Clear existing token since we're reconfiguring
        PROXMOX_API_TOKEN=""

        # Save new configuration
        save_config
    else
        # If keeping existing config, check if user wants to create/update token
        if [[ -z "$PROXMOX_API_TOKEN" ]]; then
            echo ""
            read -p "No API token found. Create one now? (y/n): " create_new_token
            if [[ "$create_new_token" != "y" && "$create_new_token" != "Y" ]]; then
                # Skip to end if user doesn't want to create token
                print_info "Configuration complete!"
                echo ""
                echo "Proxmox Details:"
                echo "  Host: $PROXMOX_HOST"
                echo "  User: $PROXMOX_USER"
                echo "  Port: $PROXMOX_PORT"
                echo ""
                print_info "This configuration can be used by other scripts:"
                echo "  source .env"
                echo ""
                exit 0
            fi
        else
            # Token exists, skip token creation
            print_info "Configuration complete!"
            echo ""
            echo "Proxmox Details:"
            echo "  Host: $PROXMOX_HOST"
            echo "  User: $PROXMOX_USER"
            echo "  Port: $PROXMOX_PORT"
            echo "  API Token: Configured (saved in .env)"
            echo ""
            print_info "This configuration can be used by other scripts:"
            echo "  source .env"
            echo ""
            print_info "For OpenTofu, configuration is already set in opentofu/terraform.tfvars"
            echo ""
            exit 0
        fi
    fi
else
    print_step "Enter Proxmox connection details"
    echo ""

    # Get Proxmox connection details
    read -p "Proxmox hostname or IP: " PROXMOX_HOST
    read -p "Proxmox username (default: root): " PROXMOX_USER
    PROXMOX_USER=${PROXMOX_USER:-root}
    read -p "Proxmox SSH port (default: 22): " PROXMOX_PORT
    PROXMOX_PORT=${PROXMOX_PORT:-22}

    # Save configuration
    save_config
fi

echo ""
print_step "SSH Key Setup"
echo ""
print_info "SSH key authentication is required for managing Proxmox via SSH."
print_info "This is needed for creating API tokens and other administrative tasks."
echo ""
read -p "Set up SSH key authentication? (y/n): " setup_ssh

if [[ "$setup_ssh" == "y" || "$setup_ssh" == "Y" ]]; then
    if ! setup_ssh_key; then
        print_warn "SSH key setup failed, but continuing..."
        print_info "You can run this script again to retry SSH setup"
    fi
else
    print_info "Skipping SSH key setup"
    print_warn "Note: SSH access is required for API token creation"
fi

echo ""
print_step "API Token Setup"
echo ""
print_info "For OpenTofu, it's recommended to use API tokens instead of passwords."
print_info "This is more secure and allows fine-grained permission control."
echo ""
read -p "Create an API token for OpenTofu? (y/n): " create_token

if [[ "$create_token" == "y" || "$create_token" == "Y" ]]; then
    echo ""
    read -p "Token user (default: terraform@pve): " token_user
    token_user=${token_user:-"terraform@pve"}

    read -p "Token ID/name (default: opentofu): " token_id
    token_id=${token_id:-"opentofu"}

    echo ""
    print_info "This will create an API token via SSH connection to Proxmox."
    print_info "You may be prompted for your SSH password if key auth is not set up."
    echo ""

    if create_api_token "$token_user" "$token_id"; then
        # Save config with token
        save_config

        echo ""
        print_info "Token has been saved to .env"
        echo ""

        # Create terraform.tfvars
        if create_terraform_tfvars; then
            print_info "You can now use OpenTofu:"
            echo "  cd opentofu"
            echo "  tofu init"
            echo "  tofu apply"
        else
            print_warn "Could not create terraform.tfvars automatically"
            print_info "Run ./copy-proxmox-token.sh to copy configuration manually"
        fi
    else
        print_warn "Continuing without API token"
        print_info "You can create a token later by running this script again"
    fi
else
    print_info "Skipping API token creation"
    print_info "You can create a token later from Proxmox web UI:"
    echo "  Datacenter → Permissions → API Tokens → Add"
fi

echo ""
print_info "Configuration complete!"
echo ""
echo "Proxmox Details:"
echo "  Host: $PROXMOX_HOST"
echo "  User: $PROXMOX_USER"
echo "  Port: $PROXMOX_PORT"
if [[ -n "$PROXMOX_API_TOKEN" ]]; then
    echo "  API Token: Configured (saved in .env)"
fi
echo ""
print_info "This configuration can be used by other scripts:"
echo "  source .env"
echo ""
print_info "For OpenTofu, configuration is already set in opentofu/terraform.tfvars"
echo ""

# Offer to create Ubuntu Noble template
echo ""
print_step "Ubuntu Noble Template Creation"
echo ""
print_info "Would you like to create an Ubuntu Noble (24.04) cloud template?"
print_info "This template can be used to quickly deploy Ubuntu VMs."
echo ""
read -p "Create Ubuntu Noble template? (y/n): " create_template

if [[ "$create_template" == "y" || "$create_template" == "Y" ]]; then
    echo ""
    print_info "Template creation options (press Enter to use defaults):"
    echo ""

    read -p "Storage name (default: local-lvm): " template_storage
    template_storage=${template_storage:-local-lvm}

    read -p "VM ID (default: 9000): " template_vmid
    template_vmid=${template_vmid:-9000}

    read -p "Template name (default: ubuntu-noble-template): " template_name
    template_name=${template_name:-ubuntu-noble-template}

    read -p "Memory in MB (default: 2048): " template_memory
    template_memory=${template_memory:-2048}

    read -p "CPU cores (default: 2): " template_cores
    template_cores=${template_cores:-2}

    echo ""

    # Call the template creation function
    if create_ubuntu_template "$template_storage" "$template_vmid" "$template_name" "$template_memory" "$template_cores"; then
        print_info "Template creation completed successfully!"
    else
        print_warn "Template creation failed or was cancelled"
    fi
else
    print_info "Skipping template creation"
    print_info "You can create a template later by running:"
    echo "  source .env"
    echo "  # Then call: create_ubuntu_template [storage] [vm_id] [name] [memory] [cores]"
fi
echo ""
